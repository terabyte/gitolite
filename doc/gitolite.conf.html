<p><head><style>
    body        { margin-left:  40px;   font-size:  0.9em;  font-family: sans-serif; max-width: 800px; }
    h1          { margin-left: -30px;   border-bottom: 5px  solid #ccc; }
    h2, h3      { margin-left: -30px;   border-top:    3px  solid #ddd; }
    h4, h5      { margin-left: -20px; }
    code        { font-size:    1.1em;  background:  #eee; }
    pre         { margin-left:  2em;    background:  #eee; }
    pre code    { font-size:    1.1em;  background:  #eee; }
</style></head></p>

<h1>the access control file <code>gitolite.conf</code></h1>

<p>In this document:</p>

<ul>
<li><a href="#_syntax">syntax</a>
<ul>
<li><a href="#_continuation_lines">continuation lines</a></li>
<li><a href="#_include_files">include files</a></li>
</ul></li>
<li><a href="#_basic_access_control">basic access control</a>
<ul>
<li><a href="#_how_rules_are_matched">how rules are matched</a></li>
<li><a href="#_branches_tags_and_specifying_refex_es">branches, tags, and specifying "refex"es</a></li>
<li><a href="#_groups">groups</a>
<ul>
<li><a href="#_the_special_all_group">the special <code>@all</code> group</a></li>
</ul></li>
</ul></li>
<li><a href="#_advanced_access_control">advanced access control</a>
<ul>
<li><a href="#_creating_and_deleting_branches">creating and deleting branches</a></li>
<li><a href="#_deny_rules">"deny" rules</a>
<ul>
<li><a href="#_IMPORTANT_NOTES_ABOUT_DENY_RULES_"><strong><em>IMPORTANT NOTES ABOUT "DENY" RULES</em></strong>:</a></li>
</ul></li>
<li><a href="#_restricting_READs_by_refname">restricting READs by refname</a></li>
</ul></li>
<li><a href="#_summary_permissions">summary: permissions</a></li>
<li><a href="#_virtual_ref_types">virtual "ref"-types</a></li>
<li><a href="#_other_tips">other tips</a>
<ul>
<li><a href="#_splitting_up_rules_into_rulesets">splitting up rules into rulesets</a></li>
<li><a href="#_gitweb_and_daemon">gitweb and daemon</a></li>
<li><a href="#_repo_specific_git_config_commands">repo specific <code>git config</code> commands</a></li>
<li><a href="#_repo_owner_description_line_for_gitweb">repo owner/description line for gitweb</a></li>
</ul></li>
</ul>

<p>Gitolite has an advanced access control language that is designed to be
powerful but easy to use.  Other objectives were that it should be even easier
to read, review and audit the rules, and it should scale to thousands of repos
and users.  There was also, in the author's mind, a desperate need to create
something as different as possible from the brain-dead, nausea-inducing
"Windows INI" style syntax that some other popular tools seem to favour.</p>

<p>This document describes the syntax and semantics of the access control rules
and other configuration directives in the <code>gitolite.conf</code> file.</p>

<p><a name="_syntax"></a></p>

<h3>syntax</h3>

<p>In general, everything is <strong>space separated</strong>; there are no commas,
semicolons, etc., in the syntax.</p>

<p><strong>Comments</strong> are in the usual shell-ish style.</p>

<p><strong>User names</strong> and <strong>repo names</strong> are as simple as possible; they must start
with an alphanumeric, but after that they can also contain <code>.</code>, <code>_</code>, or <code>-</code>.</p>

<p>Usernames can optionally be followed by an <code>@</code> and a domainname containing at
least one <code>.</code> (this allows you to use an email address as someone's username).
Reponames can contain <code>/</code> characters (this allows you to put your repos in a
tree-structure for convenience)</p>

<p><a name="_continuation_lines"></a></p>

<h4>continuation lines</h4>

<p>There are no continuation lines -- gitolite does not process C-style
backslash-escaped newlines as anything special.  However, the section on
"groups" will tell you how you can break up large lists of names in a group
definition into multiple lines.</p>

<p><a name="_include_files"></a></p>

<h4>include files</h4>

<p>Gitolite allows you to break up the configuration into multiple files and
include them in the main file for convenience.</p>

<pre><code>include     "foo.conf"
</code></pre>

<p>will include the contents of the file "foo.conf" from the same directory as
the main config file.  You can also use an absolute path if you like, although
in the interests of cloning the admin-repo sanely you should avoid doing this!</p>

<p>[Advanced users: the include statement cannot be used inside a delegated
config file, for security reasons].</p>

<p><a name="_basic_access_control"></a></p>

<h3>basic access control</h3>

<p>Here's a very basic set of rules:</p>

<pre><code>repo    gitolite-admin
        RW+     =   sitaram

repo    testing
        RW+     =   @all

repo    gitolite simplicity
        RW+     =   sitaram dilbert
        RW      =   alice ashok
        R       =   wally
</code></pre>

<p>It should be easy to guess what most of this means:</p>

<ul>
<li><code>R</code> means "read" permission</li>
<li><code>RW</code> means "read and write", but no rewind</li>
<li><code>RW+</code> means "read and write", with rewind allowed</li>
</ul>

<p>A "rewind" is more often called a "non-fast forward push"; see git docs for
what that is.  The <code>+</code> was chosen because it is part of the "git push" syntax
for non-ff pushes.</p>

<p>In a later section you'll see some more advanced permissions.</p>

<p><a name="_how_rules_are_matched"></a></p>

<h4>how rules are matched</h4>

<p>It's important to understand that there're two levels at which access control
happens.  Please see <a href="http://sitaramc.github.com/gitolite/doc/3-faq-tips-etc.html#_two_levels_of_access_rights_checking">this</a> for details, especially about the first level
check.  Much of the complexity applies only to the second level check, so that
is all we will be discussing here.  This check is done by the update hook, and
determines whether the push succeeds or fails.</p>

<p>For basic permissions like this, matching is simple.  Gitolite already knows:</p>

<ul>
<li>the user</li>
<li>the repo</li>
<li>the branch or tag ("ref") being pushed</li>
<li>whether it is a notmal (ff) push or a rewind (non-ff) push.</li>
</ul>

<p>Gitolite goes down the list of rules matching the user, repo, and the ref.
The first matching rule that has the permission you're looking for (<code>W</code> or
<code>+</code>), results in success.  A fallthrough results in failure.</p>

<p><a name="_branches_tags_and_specifying_refex_es"></a></p>

<h4>branches, tags, and specifying "refex"es</h4>

<p>One of the original goals of gitolite was to allow access control at the
branch/tag (aka "ref") level.  The git source code contains a sample update
hook that has the following in it:</p>

<pre><code># from Documentation/howto/update-hook-example.txt:

refs/heads/master       junio
+refs/heads/pu          junio
refs/heads/cogito$      pasky
refs/heads/bw/.*        linus
refs/heads/tmp/.*       .*
refs/tags/v[0-9].*      junio
</code></pre>

<p>If you did this in gitolite, this is what the equivalents would be:</p>

<pre><code>repo    git
        RW      master$             =   junio   # line 1
        RW+     pu$                 =   junio   # line 2
        RW      cogito$             =   pasky   # line 3
        RW      bw/                 =   linus   # line 4
        RW      tmp/                =   @all    # line 5
        RW      refs/tags/v[0-9]    =   junio   # line 6
</code></pre>

<p>The following points will help you understand these rules.  (Git recap:
branches and tags together are called "ref"s in git.  A branch ref usually
looks like "refs/heads/foo", while a tag ref looks like "refs/tags/bar")</p>

<ul>
<li><p>the general syntax of a paragraph of rules is:</p>

<pre><code># start line:
repo [one or more repos and/or repo groups]
# followed by one or more permissions lines:
[permission] [zero or more refexes] = [one or more users]
</code></pre></li>
<li><p>a <strong>refex</strong> is a <em>perl regex</em> that matches a ref.  When you try to push a
commit to a branch or a tag, that "ref" is matched against the refex part
of each rule</p></li>
<li><p>if the refex does not start with <code>refs/</code>, gitolite assumes a prefix of
<code>refs/heads/</code>.  This is useful because <em>branch</em> matching is the most
common case, as you can see this applies to lines 1 through 5 here.</p></li>
<li><p>if no refex appears, the rule applies to all refs in that repo</p></li>
<li><p>refexes are prefix-matched (they are internally anchored with <code>^</code> before
being used).  This means only the beginning of the actual ref needs to
match the refex, unless the refex has an explicit <code>$</code> meta-character at
the end (like the first 3 lines in our example do).</p>

<p>Line 5, for instance, allows anyone to push a branch inside the "tmp/"
namespace, while line 6 provides the ability to push version tags; "v1",
"v1.0", "v2.0rc1", all match the criterion specified by <code>v[0-9]</code> because
this is a prefix match only.</p></li>
</ul>

<p><a name="_groups"></a></p>

<h4>groups</h4>

<p>Gitolite allows you to define <strong>groups</strong> of repos. users, or even refexes.  A
group is semantically (but <em>not</em> syntactically) like a <code>#define</code> in C.  Here
is an example of each kind:</p>

<pre><code>@oss_repos  =   gitolite linux git perl rakudo entrans vkc
@staff      =   sitaram some_dev another-dev
@important  =   master$ QA_done refs/tags/v[0-9]
</code></pre>

<p>The syntax of a group definition is simply:</p>

<pre><code>@groupname = [one or more names]
</code></pre>

<p>A group can <em>accumulate</em> values.  For example:</p>

<pre><code>@staff      =   sitaram some_dev another-dev
@staff      =   au.thor
</code></pre>

<p>is the same as</p>

<pre><code>@staff      =   sitaram some_dev another-dev au.thor
</code></pre>

<p>This is more convenient than continuation lines, because it allows you to add
to a group anywhere.  Many people generate their gitolite.conf itself from
some <em>other</em> database, and it is very useful to be able to do this sort of
thing.</p>

<p>Groups can include other groups, and the included group will be expanded to
whatever value it <em>currently</em> has:</p>

<pre><code>@staff      =   sitaram some_dev another-dev    # line 1
@staff      =   au.thor                         # line 2
@interns    =   indy james                      # line 3
@alldevs    =   bob @interns                    # line 4
</code></pre>

<p>"@alldevs" expands to 7 names now.  However, remember that the config file is
parsed in a single-pass, so later <em>additions</em> to a group name cannot affect
earlier <em>uses</em> of it.  If you moved line 2 to the end, "@alldevs" would only
have 6 names in it.</p>

<p><a name="_the_special_all_group"></a></p>

<h5>the special <code>@all</code> group</h5>

<p>There's a special group called <code>@all</code> that includes all authenticated users;
you've seen examples of it earlier.</p>

<p>[Advanced users: also see the entry for <code>GL_ALL_INCLUDES_SPECIAL</code> in
<a href="http://sitaramc.github.com/gitolite/doc/gitolite.rc.html">doc/gitolite.rc.mkd</a>.]</p>

<p><a name="_advanced_access_control"></a></p>

<h3>advanced access control</h3>

<p>The previous section is sufficient for most common needs, but gitolite can go
a lot further than that.</p>

<p><a name="_creating_and_deleting_branches"></a></p>

<h4>creating and deleting branches</h4>

<p>Since the beginning of gitolite, <code>RW</code> gave the ability, not only to update,
but to <em>create</em> a branch (that matched the refex).  Similarly, <code>RW+</code> meant
being able to not only rewind, but also delete a ref.  Conceptually, a rewind
is almost the same as a delete+push (the only difference I can see is if you
had core.logAllRefUpdates set, which is <em>not</em> a default setting).</p>

<p>However, there seem to be cases where it is useful to distinguish these cases.
Arguments can be made on all sides if you're dealing with new users, so
gitolite supports that.</p>

<p>We'll look at the delete/rewind case in detail first:</p>

<ul>
<li><p>if the rules for a repo do not contain a <code>D</code> anywhere, then <code>RW+</code> will
allow both rewind and delete operations.  Apart from being more convenient
if you don't need this separation, this also ensures backward
compatibility for setups created before this separation feature was added
to gitolite).</p></li>
<li><p>if, however, <em>any</em> of the rules for a repo contains a <code>D</code> (example: <code>RWD</code>,
<code>RW+D</code>, etc) then <code>RW+</code> by itself will permit only a rewind, not a delete</p></li>
</ul>

<p>The same thing applies to create/push, where if you have a permissions like
<code>RWC</code> or <code>RW+C</code> anywhere, a simple <code>RW</code> or <code>RW+</code> can no longer <em>create</em> a new
ref.</p>

<p>You can combine the <code>C</code> and <code>D</code> also.  Thus, the set of permissions you now
know about are, in regex syntax: <code>R|RW+?C?D?</code>.  See a later section for the
full set of permissions possible.</p>

<p>Some usage hints:</p>

<ul>
<li><p>if you find that <code>RW+</code> no longer allows creation/deletion but you can't
see a <code>C</code>/<code>D</code> permission in the rules, remember that gitolite allows a
repo config to be specified in multiple places for convenience, included
delegated or included files.  Be sure to search everywhere :)</p></li>
<li><p>a quick way to make this the default for <em>all</em> your repos is:</p>

<pre><code>repo @all
    RWCD    dummy-branch    =   foo
</code></pre>

<p>where foo can be either the administrator, or if you can ignore the
warning message when you push, a non-existant user.</p></li>
</ul>

<p><a name="_deny_rules"></a></p>

<h4>"deny" rules</h4>

<p>Take a look at the following snippet, which <em>seems</em> to say that "bruce" can
write versioned tags (anything containing <code>refs/tags/v[0-9]</code>), but the other
staffers can't:</p>

<pre><code>    @staff = bruce whitfield martin
            [... and later ...]
    RW refs/tags/v[0-9]     = bruce
    RW refs/tags            = @staff
</code></pre>

<p>But that's not how the matching works.  As long as any refex matches the
refname being updated, it's a "yes".  Since the second refex (which says
"anything containing <code>refs/tags</code>") is a superset of the first one, it lets
anyone on <code>@staff</code> create versioned tags, not just Bruce.</p>

<p>So how do we say "these people can create any tags except tags that look like
this pattern"?</p>

<p>One way to fix this is to allow "deny" rules.  We make a small addition to the
permissions syntax, and define a more rigorous, ordered, interpretation.</p>

<p>Let's recap the <strong>existing semantics</strong>:</p>

<blockquote>
  <p>The first matching refex that has the permission you're looking for (<code>W</code>
  or <code>+</code>), results in success.  A fallthrough results in failure.</p>
</blockquote>

<p>Here are the <strong>new semantics</strong>, with changes from the "main" one in bold:</p>

<blockquote>
  <p>The first matching refex that has the permission you're looking for (<code>W</code>
  or <code>+</code>) <strong>or a minus (<code>-</code>)</strong>, results in success <strong>or failure,
  respectively</strong>.  A fallthrough <strong>also</strong> results in failure.</p>
</blockquote>

<p>So the example we started with becomes, if you use "deny" rules:</p>

<pre><code>    RW refs/tags/v[0-9]     = bruce
    -  refs/tags/v[0-9]     = @staff
    RW refs/tags            = @staff
</code></pre>

<p>And here's how it works:</p>

<ul>
<li>for non-version tags, only the 3rd rule matches, so anyone on staff can
push them</li>
<li>for version tags by bruce, the first rule matches so he can push them</li>
<li>for version tags by staffers <em>other than bruce</em>, the second rule matches
before the third one, and it has a <code>-</code> as the permission, so the push
fails</li>
</ul>

<p><a name="_IMPORTANT_NOTES_ABOUT_DENY_RULES_"></a></p>

<h5><strong><em>IMPORTANT NOTES ABOUT "DENY" RULES</em></strong>:</h5>

<ul>
<li><p>normally, deny rules do NOT affect read access.  They only apply to write access.
However, please also see the next section, <a href="http://sitaramc.github.com/gitolite/doc/gitolite.conf.html#_restricting_READs_by_refname">restricting reads by refname</a>.</p></li>
<li><p>when using deny rules, the order of your rules starts to matter, where
earlier it did not.  If you're just starting to add a deny rule to an
existing ruleset, it's a good idea to review the entire ruleset once, to
make sure you're doing it right.</p></li>
</ul>

<p><a name="_restricting_READs_by_refname"></a></p>

<h4>restricting READs by refname</h4>

<p><strong>IMPORTANT: UNTIL THIS NOTICE IS REMOVED, THIS FEATURE IS ONLY AVAILABLE IN
THE "rrr" BRANCH</strong>.</p>

<p>Git by itself does not enable restricting <em>read</em> access by branch/tag-name.
Until now, anyone who wanted that was told to either (a) use separate repos
for the private and public branches, with pulls going strictly one way, or (b)
use <a href="http://sitaramc.github.com/gitolite/contrib/gerrit.html">Gerrit Code Review</a>, which can do it because it uses jgit, a Java
implementation of git which has been tweaked to allow this.  There are some
complications in how it does it; see that link for more.</p>

<p>However, now we've managed to do that to.  And without having to hack git!
The idea came to me while working on <a href="http://sitaramc.github.com/gitolite/contrib/adc/hub.html">something else</a> for the KDE folks,
so you can thank them for the inspiration.</p>

<p><em>For all that, it's still a hack.  And it only works with ssh access -- don't
expect it to ever work with git-daemon or gitweb access, and even getting it
to play nice with smart http may never happen.</em></p>

<p>Here's how you can use this, if you're really desperate.  Let's say you have
the following rules for repo <code>foo</code>:</p>

<pre><code>repo foo
    R           =   u1      # line 1
    RW          =   u2      # line 2
    R   b1      =   u3      # line 3
    RW  b2      =   u4      # line 4
    RW+ temp    =   u1 u2 u3 u4
</code></pre>

<p>Gitolite before this version would give all four users the same read access to
the repository.  After all, they have each been named in some "R" or "RW" line
somewhere in that repo.  This in turn means that line 3 should actually be
just <code>R = u3</code>, because the <code>b1</code> has no effect</p>

<p>In fact, line 3 may even be the result of a misunderstanding (such as <a href="http://colabti.org/irclogger/irclogger_log/git?date=2011-02-23#l2261">this
one</a>).  So we now let that misunderstood syntax get some DWIM magic.</p>

<p>Here's the rule, starting from this revision:</p>

<blockquote>
  <p><strong>When a user has an <code>R</code> combined with an explicit refex in a set of
  rules, that user is subject to read-restrictions on that repo.</strong></p>
</blockquote>

<p>As you can see in the example above, line 3 is the only one that fits that
criterion, so user <code>u3</code> is subject to read access checks.  In this example, he
cannot fetch any branch except <code>b1</code> and <code>temp</code>.</p>

<p>Implementation notes: we create a temporary repo from which we delete all refs
that the user does not have read permission for, then quietly redirect the
access to that temporary repo.  (I already told you it's a hack!).  This does
not seem to be easy/possible in smart http mode, sadly.  Patches welcome!</p>

<p><a name="_summary_permissions"></a></p>

<h3>summary: permissions</h3>

<p>The full set of permissions, in regex syntax: <code>-|R|RW+?C?D?</code>.  This expands to
one of <code>-</code>, <code>R</code>, <code>RW</code>, <code>RW+</code>, <code>RWC</code>, <code>RW+C</code>, <code>RWD</code>, <code>RW+D</code>, <code>RWCD</code>, or
<code>RW+CD</code>.  and by now you know what they all mean.</p>

<p>[Side note: There is one more very important permissions to be dealt with --
the standalone <code>C</code>, which is not really a "ref" level permission and can be
found in doc/wildcard-repositories.mkd.]</p>

<p><a name="_virtual_ref_types"></a></p>

<h3>virtual "ref"-types</h3>

<p>This is a highly advanced topic; see <a href="http://sitaramc.github.com/gitolite/doc/virtualrefs-and-scoring.html">doc/virtualrefs-and-scoring.mkd</a> for
details.</p>

<p><a name="_other_tips"></a></p>

<h3>other tips</h3>

<p><a name="_splitting_up_rules_into_rulesets"></a></p>

<h4>splitting up rules into rulesets</h4>

<p>Gitolite lets you specify access rules for a repo in bits and pieces.  This
can be very convenient sometimes.  Let's say you have a mix of open source and
closed source projects, and "bosses" should have read access to all projects,
and everyone should have read access to open source projects.  Assuming the
appropriate group definitions, this would work:</p>

<pre><code># all bosses have read access to all projects
repo @open @closed @topsecret
    R   =   @bosses

# everyone has read access to "open" projects
repo @open
    R   =   @bosses @devs @interns
</code></pre>

<p>If you notice that <code>@bosses</code> are given read access to <code>@open</code> via both rules,
don't worry that this causes some duplication or inefficiency.  It doesn't :-)</p>

<p>Elsewhere in the file, you would specify access for individual repos (like RW,
RW+, etc).  Gitolite combines all of these access rules, maintaining the
textual order in which they occur, when authorising a push.</p>

<p>This feature also helps people who generate their gitolite.conf itself from
some <em>other</em> database -- it allows them much more flexibility in how they
generate rules.</p>

<p><a name="_gitweb_and_daemon"></a></p>

<h4>gitweb and daemon</h4>

<p>Gitolite allows you to specify access for git-daemon and gitweb.  See
<a href="http://sitaramc.github.com/gitolite/doc/2-admin.html#gwd">this</a> for more on this.</p>

<p><a name="_repo_specific_git_config_commands"></a></p>

<h4>repo specific <code>git config</code> commands</h4>

<p>(Thanks to teemu dot matilainen at iki dot fi)</p>

<p>Sometimes you want to specify <code>git config</code> settings for some of your repos.
For example, you may have a custom post-receive hook that sends an email when
a push happens, and this hook needs to know whom to send the email to, etc.</p>

<p>You can set git config values by specifying something like this within a
"repo" paragraph:</p>

<p>example usage: if you placed a hook in hooks/common that requires
configuration information that is specific to each repo, you could do this:</p>

<pre><code>repo gitolite
    config hooks.mailinglist = gitolite-commits@example.tld
    config hooks.emailprefix = "[gitolite] "
    config foo.bar = ""
    config foo.baz =
</code></pre>

<p>The syntax is simple:</p>

<pre><code>config sectionname.keyname = [optional value_string]
</code></pre>

<p>This does either a plain "git config section.key value" (for the first 3
examples above) or "git config --unset-all section.key" (for the last
example).  Other forms (--add, the <code>value_regex</code>, etc) are not supported.</p>

<p><strong>Note</strong>: this won't work unless the rc file has the right settings; please
see comments around the variable <code>$GL_GITCONFIG_KEYS</code> in doc/gitolite.rc.mkd
for details and security information.</p>

<p><a name="_repo_owner_description_line_for_gitweb"></a></p>

<h4>repo owner/description line for gitweb</h4>

<p>Including a line like this:</p>

<pre><code>gitolite "Sitaram Chamarty" = "fast, secure, access control for git in a corporate environment"
</code></pre>

<p>sets the owner name and description for gitweb.  The general syntax is very
simple, just use one of:</p>

<pre><code>reponame = "some description string in double quotes"
reponame "owner name" = "some description string in double quotes"
</code></pre>

<p>Note: setting a description also gives gitweb access; you do not have to give
gitweb access explicitly (as described or linked above) if you're specifying a
description.</p>
